chackra:
  https://v2.chakra-ui.com/docs/components/card/usage

  c:
    npm i @chakra-ui/react@2.8.2 @emotion/react@11.11.4 @emotion/styled@11.11.5 framer-motion@11.1.7 axios@1.6.8 react-icons@5.0.1 react-hook-form@7.51.3

1) creamos los componentes:
  meal-finder/src/components/Categories.tsx
  meal-finder/src/components/Header.tsx
  meal-finder/src/components/MainContent.tsx
  meal-finder/src/components/MealCard.tsx
  meal-finder/src/components/SideNav.tsx

  n: como chacra y toos los frameworks tienen un Modal 
  entonces para que no se equivoque con el modal de chakra
  creare un componente modal con un nombre diferente

  meal-finder/src/components/RecipeModal.tsx
2) creo el Grilla: Una grilla (o grid en inglés) es un sistema de diseño que permite organizar elementos en filas y columnas,
 creando una estructura visualmente coherente y  ordenada para una página web 
  u: meal-finder\src\App-sinCustomhook.tsx
  meal-finder\src\App-sinhook.tsx
  s:
    //---------------------------------el height se hace un pequeño calculo para que toem el resto de altura y solo le resta la altura de 60px que seria el del header 
    // // import { useState } from 'react';
    // // import './App.css';
    // // import { Grid, GridItem } from '@chakra-ui/react';
    // // import Header from './components/Header';
    // // import SideNav from './components/SideNav';
    // // import MainContent from './components/MainContent';
    // // function App() {
    // //   const [count, setCount] = useState(0);
    // //   return (
    // //     <Grid
    // //       templateAreas={`"header header"
    // //                   "nav main"`}
    // //       gridTemplateRows={'60px 1fr '}
    // //       gridTemplateColumns={{ sm: `0 1fr`, md: `250px 1fr` }}
    // //     >
    // //       <GridItem pl="2" bg="orange.300" area={'header'}>
    // //         <Header></Header>
    // //       </GridItem>
    // //       <GridItem pl="2" bg="pink.300" area={'nav'} height="calc(100vh - 60px)">
    // //         <SideNav></SideNav>
    // //       </GridItem>
    // //       <GridItem pl="2" bg="green.300" area={'main'}>
    // //         <MainContent></MainContent>
    // //       </GridItem>
    // //     </Grid>
    // //   );
    // // }
    // // export default App;

3)Uso de AXIOS 
    api: https://www.themealdb.com/

  n: constuyo mi customhook para traer data, aqui si se hace con axios
  n: inicalmente se puede probar en el App.tsx
  u: meal-finder\src\App-sinCustomhook.tsx
  s:
  // //const url = 'https://www.themealdb.com/api/json/v1/1/list.php?c=list';
  // // const [data, setData] = useState([]);
  // // const [loading, setLoading] = useState<boolean>(false);
  // // useEffect(() => {
  // //   const controller = new AbortController();
  // //   const { signal } = controller;

  // //   setLoading(true);
  // //   axios
  // //     .get(url, { signal })
  // //     // .then((re) => { //----sin destructuracion
  // //     .then(({ data }) => {
  // //       // setData(re.data.meals); //----sin destructuracion
  // //       setData(data.meals);
  // //     })
  // //     .finally(() => {
  // //       setLoading(false);
  // //     });

  // //   return () => controller.abort();
  // // }, []);))
    
4) ahora tengo que definir los tipos para que no me quede undenied:
  n: creo el directorio 
  u: meal-finder\src\types\index.ts

  s: 
  // // export type Category = {
  // //   strCategory: string;
  // // };
  // // export type CategoriesResponse = {
  // //   meals: Category[];
  // // };


  4.1) ahora que ya tengo los tipos puedo agregarle los tipos a el codigo 
    u: meal-finder\src\App-sinCustomhook.tsx
    s:
      // // const [data, setData] = useState<Category[]>([]); //----la data va ser un arreglo de category
      ....
      ....
      // // axios
      // // .get<CategoriesResponse>(url, { signal }) //----La respuesta del api es de tipo "CategoriesResponse"

5) pasandole al SideNav las Categories y listando (stack en chakra)
  u:  meal-finder\src\App-sinCustomhook.tsx
  s: 
    <SideNav categories={data} loading={loading}>
        </SideNav>

  5.1) creo el SideNav
    u: meal-finder\src\components\SideNav.tsx
    s: 
      // // import React from 'react';
      // // import { Category } from '../types';
      // // import { Box, Heading, Link, StackDivider, VStack } from '@chakra-ui/react';
      // // import { color } from 'framer-motion';

      // // type Props = {
      // //   categories: Category[];
      // //   loading: boolean;
      // // };

      // // const selectedProps = {
      // //   bgColor: 'blue.400',
      // //   color: 'white',
      // //   fontWeight: 'bold',
      // // };
      // // function SideNav({ categories, loading }: Props) {
      // //   const selected = {
      // //     strCategory: 'Beef',
      // //   };
      // //   return (
      // //     <>
      // //       <Heading color="green.400" fontSize={12} fontWeight="bold" mb="4">
      // //         Categories
      // //       </Heading>
      // //       <VStack align="stretch">
      // //         {categories.map((category) => (
      // //           <Link
      // //             _hover={{ textDecoration: 'none' }}
      // //             key={category.strCategory}
      // //             h="40px"
      // //             bg="yellow.200"
      // //             px={2}
      // //             py={1}
      // //             borderRadius="5"
      //-----Este codigo auqi con una logica permite que se den unos estilos dependiendo de esa logica
      // //             {...(selected.strCategory === category.strCategory && selectedProps)}
      // //           >
      // //             {category.strCategory}
      // //           </Link>
      // //         ))}
      // //       </VStack>
      // //     </>
      // //   );
      // // }

      // // export default SideNav;

  5.2) opcio de que cuando de click en un boton se pone azulito o
    u:
    s://----creo el estado: 
      // //  const [selectedCategory, setSelectedCategory] = useState<Category>({ strCategory: 'Beef' });
      //----Le paso el estado 
      // //   
      // //  <SideNav
      // //    selectedCategory={selectedCategory}
      // //    setSelectedCategory={setSelectedCategory}
      // //    categories={data}
      // //    loading={loading}
      // //   ></SideNav>

    5.2.2) 
    u: ahor aen el componente le agrego las propiedades
    U: meal-finder\src\components\SideNav.tsx
    s:
      // // type Props = {
      // //   categories: Category[];
      // //   loading: boolean;
      // //   selectedCategory: Category;
      // //   setSelectedCategory: (category: Category) => void;
      // // };
      ...
      ..
      // // function SideNav({ categories, loading, selectedCategory: selected, setSelectedCategory }: Props) {
      // //    return (
      // //    <>
      // //     <Heading color="green.400" fontSize={12} fontWeight="bold" mb="4">
      // //       CATEGORIAS
      // //     </Heading>
      // //    <VStack align="stretch">
      // //        {categories.map((category) => (
      // //         <Link
      // //-----agrego la funcion de cambio de el estado al hacer click en elink 
      // //            onClick={() => setSelectedCategory(category)}
            

6) los skeleton o barritas de cargando, (cargamos las categorias )
  url: https://v2.chakra-ui.com/docs/components/skeleton/usage
  u:  meal-finder\src\App-sinCustomhook.tsx
  s:  
      ////....
      ////..
      // // function App() {
      // // ....
      // //   useEffect(() => {
      // //     let ignore = false;  //----Agrego una bandera para que cuando pase la primera vez sea falso 
      // // ....
      // //     axios
      // //       .get<CategoriesResponse>(url, { signal })
      // //       .then(({ data }) => {
      // //         if (!ignore) {//----la primera vez falso entonces ejecuta el set, la segunda vez cuando termina el proceso ya no puede entrar
      // //           //----si tiene que ignorar entonces no vuelve a setear
      // //           setData(data.meals);
      // //         }
      // //       })
      // //       .finally(() => {
      // //         if (!ignore) {
      // //           //----si tiene que ignorar entonces no vuelve a setear
      // //           setLoading(false);
      // //         }
      // //       });

      // //     return () => {
      // //       ignore = true; //----cuando se sale o termina el proceso(la 1era vez) entonces pone en true pa que no vuelva a ejecutar el set de react
      // //       controller.abort();
      // //     };
      // //   }, []);

      // //   return (
      // //     <Grid
      // //       templateAreas={`"header header"
      // //                   "nav main"`}
      // //       gridTemplateRows={'60px 1fr '}
      // //       gridTemplateColumns={{ sm: `0 1fr`, md: `250px 1fr` }}
      // //       fontSize={14}
      // //     >
      // //       <GridItem pl="2" bg="orange.300" area={'header'}>
      // //         <Header></Header>
      // //       </GridItem>
      // //       <GridItem p="5" area={'nav'} height="calc(100vh - 60px)">
      // //         <SideNav
      // //           selectedCategory={selectedCategory}
      // //           setSelectedCategory={setSelectedCategory}
      // //           categories={data}
      // //           loading={loading}
      // //         ></SideNav>
      // //       </GridItem>
      // //       <GridItem pl="2" bg="green.300" area={'main'}>
      // //         <MainContent></MainContent>
      // //       </GridItem>
      // //     </Grid>
      // //   );
      // // }

      // // export default App;
      // //))
  6.1) 
    u: meal-finder\src\components\SideNav.tsx
    s:  
      // //   function SideNav({ categories, loading, selectedCategory: selected, setSelectedCategory }: Props) {
      // //   console.log(loading);
      // //   return loading ? ( //---Aqui depende s el estado es o no loading deja ver el skeleton sino solo muestra el resto de contenido
      // //     <SkeletonText mt="4" noOfLines={4} spacing="4" skeletonHeight="2" /> //----este es el skeleton 
      // //   ) : (
      // //     <>

  6.2) explcacion de el porque usar el Flag
      
      Flujo Detallado
      Primera Ejecución del useEffect:

        -Se lanza la petición axios.
        -Antes de que la petición finalice, el useEffect se limpia (por ejemplo, debido a un desmontaje o re-renderizado del componente), lo que cancela la petición con controller.abort().
        -Debido a la cancelación, la promesa no resuelve exitosamente, por lo que el then no se ejecuta. Solo el finally se ejecuta con ignore ya en true.
      Segunda Ejecución del useEffect:

        -Dependiendo de tu aplicación, puede haber una segunda ejecución del useEffect, ya sea por un cambio en el estado del componente, un nuevo renderizado o algún otro motivo.
        En esta segunda ejecución:
        -Se lanza una nueva petición axios.
        -Esta vez, la petición se completa antes de que la función de limpieza del useEffect se ejecute.
        -Dado que la petición se completó con éxito, el then se ejecuta y ves el log ---1er then.


      Primera Ejecución:
      ---cero then false time: 226.564 → El useEffect empieza.
      ---3er return false time: 226.564 → La función de limpieza se ejecuta, cancelando la petición.
      ---2do finally true time: 226.564 → La promesa se cancela y el finally se ejecuta.
      Segunda Ejecución:
      ---cero then false time: 476.526 → El useEffect se ejecuta nuevamente.
      ---1er then false time: 476.526 → La petición completa correctamente, y el then se ejecuta.
      ---2do finally false time: 476.526 → La promesa completa y el finally se ejecuta con ignore como false.
        
7) custom hook 
  n: creo el hook en una carpeta de hooks:
  u: meal-finder\src\hooks\useHttpData.ts
  n: para usar este hook que sirva pa varios lo bueno es que las dos apis debuelven:
    ▶️ categorias:https://www.themealdb.com/api/json/v1/1/list.php?c=list
       Respuesta: 
            {      
              "meals": [
                {
                  "strCategory": "Beef"
                },
                {
                  "strCategory": "Chicken"
                },
              ]
            }
    ▶️ filtro de una categoria:       https://www.themealdb.com/api/json/v1/1/filter.php?c=Seafood
      Respuesta:
              {
                "meals": [
                  {
                    "strMeal": "Baked salmon with fennel & tomatoes",
                    "strMealThumb": "https://www.themealdb.com/images/media/meals/1548772327.jpg",
                    "idMeal": "52959"
                  },
                  {
                    "strMeal": "Cajun spiced fish tacos",
                    "strMealThumb": "https://www.themealdb.com/images/media/meals/uvuyxu1503067369.jpg",
                    "idMeal": "52819"
                  },
                ]
              }
    n: como ambas devuelven sus respuestas dentro de meal por eso se puee colocar
    en el axios.get<{ meals: T[] }>(url, { signal })

  s:  
    // // import { useEffect, useState } from 'react';
    // // import { CategoriesResponse, Category } from '../types';
    // // import axios from 'axios';
    // // export default function useHttpData<T>(url: string) {
    // //   const [data, setData] = useState<T[]>([]);
    // //   const [loading, setLoading] = useState<boolean>(false);
    // //   useEffect(() => {
    // //     let ignore = false;
    // //     const controller = new AbortController();
    // //     const { signal } = controller;
    // //     setLoading(true);
    // //     console.log('---cero then', ignore, 'time:', document.timeline.currentTime);

    // //     axios
    // //       .get<{ meals: T[] }>(url, { signal })
    // //       // .then((re) => { //----sin destructuracion
    // //       .then(({ data }) => {
    // //         console.log('---1er then', ignore, 'time:', document.timeline.currentTime);
    // //         // setData(re.data.meals); //----sin destructuracion
    // //         if (!ignore) {
    // //           //----si tiene que ignorar entonces no vuelve a setear
    // //           setData(data.meals);
    // //         }
    // //       })
    // //       .finally(() => {
    // //         console.log('---2do finnally', ignore, 'time:', document.timeline.currentTime);

    // //         if (!ignore) {
    // //           //----si tiene que ignorar entonces no vuelve a setear
    // //           setLoading(false);
    // //         }
    // //       });

    // //     return () => {
    // //       console.log('---3er return ', ignore, 'time:', document.timeline.currentTime);

    // //       ignore = true; //----cuando se sale o termina el proceso(la 1era vez) entonces pone en true pa que no vuelva a ejecutar el set de react
    // //       controller.abort();
    // //     };
    // //   }, []);

    // //   return { data, loading };
    // // }
    )
    
  7.1) ahora como ya utilice el meals: T[] ➡️ " axios.get<{ meals: T[] }>(url, { signal })"
    ya no se necesita en el types

      U:meal-finder\src\types\index.ts
      s:  // export type CategoriesResponse = { //--ya no se necesitaria porque ya lo coloque en el axios.get<{meals: T[]}>(url, {signal})
          //   meals: Category[];
          // };

  7.2) ahora para usar le customhook:
    u: meal-finder\src\App.tsx
    s:
      // //   function App() {
      // //   const url = 'https://www.themealdb.com/api/json/v1/1/list.php?c=list';
      // //   const [selectedCategory, setSelectedCategory] = useState<Category>({ strCategory: 'Beef' });
      // //   const { data, loading } = useHttpData<Category>(url);
      // //   return (
      // //     <Grid
      // //       templateAreas={`"header header"
      // //                   "nav main"`}
      // //       gridTemplateRows={'60px 1fr '}
      // //       gridTemplateColumns={{ sm: `0 1fr`, md: `250px 1fr` }}
      // //       fontSize={14}
      // //     >
      )

  7.3) para  el uso del hook para la url de meal 
    n: creo el typo 
    u:meal-finder\src\types\index.ts
    s:
      // // export type Meal = {
      // //   //-----se le coloco el mismo nombre del objeto pero perfectamente se podria otro nombre
      // //   strMeal: string;
      // //   strMealThumb: string;
      // //   idMeal: string;
      // // };
   
    7.3.2) 
      u:
      s://.........
        // // const url = 'https://www.themealdb.com/api/json/v1/1/list.php?c=list';
        // // const defaultCategory: Category = { strCategory: 'Beef' }; //------categoria por defecto
        //----creo una pequeña fucnion que al recibir la categoria por defecto la ponga en el url 
        // // const makeMealUrl = (category: Category) =>
        // //   `https://www.themealdb.com/api/json/v1/1/filter.php?c=${category.strCategory}`;

        // // function App() {
        // //   const [selectedCategory, setSelectedCategory] = useState<Category>(defaultCategory);
        // //   const { data, loading } = useHttpData<Category>(url);
        //--------ahora si agrego el uso del custom hook pero on la segunda url 
        // //   const { data: dataMeal, loading: loadingMeal } = useHttpData<Meal>(makeMealUrl(defaultCategory));
        // //   console.log('data:', { dataMeal });
        // //   return (
        // //     <Grid)........

8) ahora cargaremos las "meals" de cada categoria
  u: meal-finder\src\App.tsx
  s:
    ...
     <MainContent
#### Ubicación del archivo:

`meal-finder\src\types\index.ts`ntent loading={loadingMeal} meals={dataMeal}></MainContent>
     ...
  8.1) le vamos a agregar esso nuevos props al componente 
    u: meal-finder\src\components\MainContent.tsx
    s: 
      // // import React from 'react';
      // // import { Meal } from '../types';
      // // import {
      // //   Box,
      // //   Button,
      // //   ButtonGroup,
      // //   Card,
      // //   CardBody,
      // //   CardFooter,
      // //   Divider,
      // //   Heading,
      // //   Image,
      // //   SimpleGrid,
      // //   Stack,
      // //   Text,
      // // } from '@chakra-ui/react';

      // // type Props = {
      // //   loading: boolean;
      // //   meals: Meal[];
      // // };

      // // function MainContent({ loading, meals }: Props) {
      // //   console.log('meals:', meals, loading);
      // //   return (
      // //     <>
      // //       <SimpleGrid columns={[1, 2, null, 3]} spacing="40px">
      // //         {meals.map((meal) => (
      // //           <Card maxW="sm" key={meal.idMeal} boxShadow="lg">
      // //             <CardBody>
      // //               <Image src={meal.strMealThumb} alt={meal.strMeal} borderRadius="lg" />
      // //               <Stack mt="6" spacing="3">
      // //                 <Heading size="md" color="blue.400">
      // //                   <Text mt="4">{meal.strMeal}</Text>
      // //                 </Heading>
      // //                 <Text>
      // //                   This sofa is perfect for modern tropical spaces, baroque inspired spaces, earthy
      // //                   toned spaces and for people who love a chic design with a sprinkle of vintage
      // //                   design.
      // //                 </Text>
      // //                 <Text color="blue.600" fontSize="2xl">
      // //                   $450
      // //                 </Text>
      // //               </Stack>
      // //             </CardBody>
      // //             <CardFooter pt={0}>
      // //               <ButtonGroup spacing="2">
      // //                 <Button colorScheme="white" bgColor={'blue.400'}>
      // //                   Ver Receta
      // //                 </Button>
      // //                 <Button variant="ghost" colorScheme="blue">
      // //                   Add to cart
      // //                 </Button>
      // //               </ButtonGroup>
      // //             </CardFooter>
      // //           </Card>
      // //         ))}
      // //       </SimpleGrid>
      // //     </>
      // //   );
      // // }

      // // export default MainContent;

  8.2) boxShadow, position absolute, relative, fixed y sticky, overflowY
    u: meal-finder\src\App.tsx
    s:
      // // <GridItem
      // //       overflowY="auto"
      // //       pos="sticky"
      // //       top="60px"
      // //       left="0px"
      // //       p="5"
      // //       area={'nav'}
      // //       height="calc(100vh - 60px)"
      // //     >


      
9) creando componente  Card para no dejar todo en maincontent y su skeleton
  n: voy a copiar lo que estave en mainconten,
     y se lo pasare a el MealCard y al SkeletonCard
  u: meal-finder\src\components\MainContent.tsx
  n: asi que queda de la siguiente manera
  s:
      // // import React from 'react';
      // // import { Meal } from '../types';
      // // import MealCard from './MealCard';
      // // import { SimpleGrid } from '@chakra-ui/react';
      // // import SkeletonCard from './SkeletonCard';
      // // type Props = {
      // //   loading: boolean;
      // //   meals: Meal[];
      // // };
      // // function MainContent({ loading, meals }: Props) {
      // //   const skeletons = [1, 2, 3, 4, 5, 6, 7, 8];
      // //   return (
      // //     <>
      // //       <SimpleGrid columns={[1, 2, null, 3]} spacing="20px">
      // //         {loading && skeletons.map((skeleton) => <SkeletonCard key={skeleton} />)}
      // //         {!loading && meals.map((meal) => <MealCard key={meal.idMeal} meal={meal} />)}
      // //       </SimpleGrid>
      // //     </>
      // //   );
      // // }
      // // export default MainContent;
  9.1) creo el componete MealCard
    u: meal-finder\src\components\MealCard.tsx
    s:
      // // import {Button,ButtonGroup,Card,CardBody,CardFooter,Heading,Image,Stack,Text} from '@chakra-ui/react';
      // // import { Meal } from '../types';
      // // type Props = {
      // //   meal: Meal;
      // // };

      // // function MealCard({ meal }: Props) {
      // //   return (
      // //     <Card maxW="sm" boxShadow="lg">
      // //       <CardBody>
      // //         <Image src={meal.strMealThumb} alt={meal.strMeal} borderRadius="lg" />
      // //         <Stack mt="6" spacing="3">
      // //           <Heading size="md" color="blue.400">
      // //             <Text mt="4">{meal.strMeal}</Text>
      // //           </Heading>
      // //           <Text>
      // //             This sofa is perfect for modern tropical spaces, baroque inspired spaces, earthy toned
      // //             spaces and for people who love a chic design with a sprinkle of vintage design.
      // //           </Text>
      // //           <Text color="blue.600" fontSize="2xl">
      // //             $450
      // //           </Text>
      // //         </Stack>
      // //       </CardBody>
      // //       <CardFooter pt={0}>
      // //         <ButtonGroup spacing="2">
      // //           <Button colorScheme="white" bgColor={'blue.400'}>
      // //             Ver Receta
      // //           </Button>
      // //           <Button variant="ghost" colorScheme="blue">
      // //             Add to cart
      // //           </Button>
      // //         </ButtonGroup>
      // //       </CardFooter>
      // //     </Card>
      // //   );
      // // }

      // // export default MealCard;
  9.2) creo el componete SkeletonCard
    u: meal-finder\src\components\SkeletonCard.tsx
    s:
      // // import { Card, CardBody, SkeletonText } from '@chakra-ui/react';
      // // function SkeletonCard() {
      // //   return (
      // //     <>
      // //       <Card maxW="sm" boxShadow="lg">
      // //         <CardBody>
      // //           <SkeletonText mt="1" noOfLines={1} spacing="4" skeletonHeight="100" />
      // //           <SkeletonText mt="4" noOfLines={2} spacing="4" skeletonHeight="4" />
      // //         </CardBody>
      // //       </Card>
      // //     </>
      // //   );
      // // }
      // // export default SkeletonCard;


10) ahora creamos la barra de busqueda con su formulario 
  u: meal-finder\src\components\Header-sinschema.tsx
  s:
    // // import { InputGroup, InputLeftElement, Stack, Input, Container } from '@chakra-ui/react';
    // // import { CiSearch } from 'react-icons/ci';
    // // type Props = {};
    // // function Header({}: Props) {
    // //   return (
    // //     <Container mt="1" maxW="3xl">
    // //       <Stack spacing={1} pl={10} pr={10}>
    // //         <InputGroup>
    // //           <InputLeftElement pointerEvents="none">
    // //             <CiSearch color="blue" size={50} />
    // //           </InputLeftElement>
    // //           <Input type="tel" placeholder="Intena con 'chicken' o 'beans'" />
    // //         </InputGroup>
    // //       </Stack>
    // //     </Container>
    // //   );
    // // }
    // // export default Header;
    
  10.1) luego podemos hacer la validaciones con reack form 
    u: meal-finder\src\types\index.ts
    n: creo el typo de la respuesta que tendre del formulario
    s:
      // // export type SearchForm = {
      // //   search: boolean;
      // // };

    10.1.2) una vez que ya tengo eso lo podre usar en el componente 
      u: meal-finder\src\components\Header.tsx
      n: uso algunas clases y componentes de chackra ui
      s:
        // // import { InputGroup, InputLeftElement, Stack, Input, Container, Button } from '@chakra-ui/react';
        // // import { useForm } from 'react-hook-form';
        // // import { CiSearch } from 'react-icons/ci';
        // // import { SearchForm } from '../types';
        // // type Props = {
        // //   onSubmit: (data: SearchForm) => void;
        // // };
        // // function Header({ onSubmit }: Props) {
        // //   const {
        // //     register,
        // //     formState: { errors },
        // //     handleSubmit,
        // //   } = useForm<SearchForm>(); //---se agrega el useForm para poder utilizarlo en el formulario
        // //   return (
        // //     <Container mt="1" maxW="3xl">
        // //       <form onSubmit={handleSubmit(onSubmit)}>
        // //         <InputGroup>
        // //           <InputLeftElement pointerEvents="none">
        // //             <CiSearch color="blue" size={50} /> {/*--se agrega un icono*/}
        // //           </InputLeftElement>
        // //           <Input
        // //             mr={5}
        // //             focusBorderColor={errors.search ? 'red.500' : 'blue.500'}
        // //             isInvalid={!!errors.search}  //---se agrega para que se muestre el borde rojo si es invalido la informacion
        // //             {...register('search', {  //---se agrega el register para que se pueda registrar el campo al "useForm"
        // //               required: 'Este campo es requerido',
        // //               minLength: { value: 2, message: 'Mínimo 2 caracteres' },
        // //             })}
        // //             type="tel"
        // //             placeholder="Intena con 'chicken' o 'beans'"
        // //           />
        // //           <Button color="white" type="submit" bgColor="blue.400">
        // //             Buscar
        // //           </Button>
        // //           {errors.search && <span>{errors?.search?.message}</span>}
        // //         </InputGroup>
        // //         {/* {formState?.errors?.search ? `${formState.errors.search.message}` : ''} */}
        // //       </form>
        // //     </Container>
        // //   );
        // // }
        // // export default Header;
11) ahora buscamos en la api con lo que se manda en el formulario

    n: en el header donde se  en cuentra el buscador 
    u: meal-finder\src\components\Header.tsx
    s:
      // // type Props = {
      // //   onSubmit: (data: SearchForm) => void;
      // // };
      // // function Header({ onSubmit }: Props) {
      // // ...
      // // ..
      // // return (
      // //  <Container mt="1" maxW="3xl">
      // //    <form onSubmit={handleSubmit(onSubmit)}> 
      // // .........)}

  11.1) ahora creo en el App el llamado de ese dato que se inserta en el search 
    
    
    u: meal-finder\src\App.tsx
    s: 
      ...
        // // function App() {
        // // ...
        // // const {
        // //   data: dataMeal,
        // //   loading: loadingMeal,
        // //   setData: setMeals, //--------saco del useHttpData esto para que cuando busque sete nuevamente la data a mostrar (data buscada)
        // //   setLoading: setLoadingMeal, //--------saco del useHttpData esto para que cuando busque setee nuevamente el skeleton  a mostrar (data buscada)
        // // } = useHttpData<Meal>(makeMealUrl(defaultCategory));
        // //....
        // //    const searchApi = (SearchForm: SearchForm) => {
        // //   const url = `https://www.themealdb.com/api/json/v1/1/search.php?s=${SearchForm.search}`;
        // //   setLoadingMeal(true);  //----------seteo el estado del skeleton 
        // //   axios
        // //     .get<{ meals: Meal[] }>(url)
        // //     .then((r) => {
        // //       setMeals(r.data.meals); //-----seteo la data a mostrar
        // //       console.log('r', r);
        // //     })
        // //     .finally(() => {
        // //       console.log('finnally');
        // //       setLoadingMeal(false);
        // //     });
        // // };
        // //...
        // //    <Header onSubmit={searchApi}></Header>
  11.2) no olvidar exportar el setData y setLoading de:
    u: meal-finder\src\hooks\useHttpData.ts
    s:
      return { data, loading, setData, setLoading };

 
    u: App-11b-SearchconCustomHook.tsx
    s:
    // // ...
    // // function App() {
    // //   ...
    // //    const {
    // //     data: dataMeal,
    // //     loading: loadingMeal,
    // //     // setData: setMeals, --------ya no uso esto
    // //     // setLoading: setLoadingMeal,--------ya no uso esto
    // //   } = useHttpData<Meal>(makeMealUrl(defaultCategory));
    // //     //-----------forma 2 de hacerl la busqueda con el uso del custom hook
    // //     const [urlSearch, setUrlSearch] = useState<string>('');
    // //     const { data: searchData, loading: searchLoading } = useHttpData<Meal>(urlSearch, urlSearch);
    // //     const searchApi = (SearchForm: SearchForm) => {
    // //       setUrlSearch(`https://www.themealdb.com/api/json/v1/1/search.php?s=${SearchForm.search}`);
    // //       console.log('urlSearch', urlSearch);
    // //       console.log('searchData', searchData);
    // //     };
    // //     //-----------fin forma 2 de hacerl la busqueda con el uso del custom hook
    // //     return(
    // //     ....
    // //       {/* forma 2 de hacerlo con el custom hook */}
    // //       {!searchData && <MainContent loading={loadingMeal} meals={dataMeal}></MainContent>}
    // //       {searchData && <MainContent loading={searchLoading} meals={searchData}></MainContent>}
    // //       {/* fin  forma 2 de hacerlo con el custom hook */}
    // //     )
    
    11.2b) ahora en el useHttpData solo agrego el state que me actualiza 
     solo cuanndo cambia el dato de la palabra search:
      u: meal-finder\src\hooks\useHttpData.ts
      s:
      // //  export default function useHttpData<T>(url: string, urlSearch?: string) {
      // //   useEffect(() => {
      // //   ....
      // //   }, [urlSearch]); //-----agrego este estado que hace que se eejecute el usefect una vez cambie este
      // //  }

12) agregando modal (pop up)
  voy y modifico el 
  u: meal-finder\src\components\RecipeModal.tsx
  n: uso el coponnete modal de chackra
  s:
      // // import {
      // //   Button,
      // //   Modal,
      // //   ModalBody,
      // //   ModalCloseButton,
      // //   ModalContent,
      // //   ModalFooter,
      // //   ModalHeader,
      // //   ModalOverlay,
      // // } from '@chakra-ui/react';

      // // type Props = {
      // //   isOpen: boolean;
      // //   onClose: () => void;
      // // };

      // // function RecipeModal({ isOpen, onClose }: Props) {
      // //   return (
      // //     <>
      // //       <Modal isOpen={isOpen} onClose={onClose}>
      // //         <ModalOverlay />
      // //         <ModalContent>
      // //           <ModalHeader>Modal Title</ModalHeader>
      // //           <ModalCloseButton />
      // //           <ModalBody>Holamundo</ModalBody>

      // //           <ModalFooter>
      // //             <Button colorScheme="blue" mr={3} onClick={onClose}>
      // //               Close
      // //             </Button>
      // //             <Button variant="ghost">Secondary Action</Button>
      // //           </ModalFooter>
      // //         </ModalContent>
      // //       </Modal>
      // //     </>
      // //   );
      // // }

      // // export default RecipeModal;
 12.2) voy al app principal para pasarle las poriedades de oOpen y Onclose a las cards:
  u:     meal-finder\src\App.tsx

  s:
    // // ...
    // // function App() {
    // //   const { isOpen, onOpen, onClose } = useDisclosure();
    // // ....
    // // ...
    // //   <GridItem p="4" bg="gray.300" area={'main'}>
    // //           <MainContent openRecipe={onOpen} loading={loadingMeal} meals={dataMeal}></MainContent>
    // //         </GridItem>
    // //       </Grid>
    // // //----queda por fuera ya que esto parece cmo pop up 
    // //   <RecipeModal isOpen={isOpen} onClose={onClose} />



  12.3) luego voy al maincontent que posee todas las cartas 
   u: meal-finder\src\components\MainContent.tsx
   s:
      // // ...
      // // type Props = {
      // //   loading: boolean;
      // //   meals: Meal[];
      // //   openRecipe: (meal: Meal) => void;  //-----agregado
      // // };

      // // function MainContent({ loading, meals, openRecipe }: Props) {
      // //   const skeletons = [1, 2, 3, 4, 5, 6, 7, 8];
      // //   return (
      // //     <>
      // //       <button style={{ cursor: 'pointer' }}>click opopen </button>
      // //       <SimpleGrid columns={[1, 2, null, 3]} spacing="20px">
      // //         {loading && skeletons.map((skeleton) => <SkeletonCard key={skeleton} />)}
      // // //--------le agrego  al MealCard el openRecipe pero le paso el argumento meal,
      // // //--------no sabia que se le podia pasar el meal:Meal y que se pudiera         
      // //         {!loading &&
      // //           meals.map((meal) => (
      // //             <MealCard openRecipe={() => openRecipe(meal)} key={meal.idMeal} meal={meal} />
      // //           ))}
      // //       </SimpleGrid>
      // //     </>
      // //   );
      // // }

  12.4) ahora voy al MealCard
    u: meal-finder\src\components\MealCard.tsx
    s:
      // // type Props = {
      // //   meal: Meal;
      // //   openRecipe: () => void; //----aqui lo pone como si no tuviera argumento 
      // // };
      // // function MealCard({ openRecipe, meal }: Props) {
      // //   return (
      // //       ....
      // //       ...
      // //       <Button onClick={openRecipe} colorScheme="white" bgColor={'blue.400'}>
      // //             Ver Receta
      // //       </Button>
      // //       ...
      // //   )
      // // }

13) creacion de custom-hook para llamado de data unicamente
  u: meal-finder\src\hooks\useFetch.ts
  s:
    // // import axios from 'axios';
    // // import { useState } from 'react';
    // // export default <T>() => {
    // //   const [loading, setLoading] = useState<boolean>(false);
    // //   const [data, setData] = useState<T>([]);
    // //   const fetch = (url: string) => {
    // //     setLoading(true);
    // //     axios.get(url)
    // //     .then((response) => {
    // //       console.log(response.data);
    // //        setData(response.data);
    // //     })
    // //     .finally(() => {
    // //       setLoading(false);
    // //     });
    // //   };
    // //   return { loading, data, fetch };
    // // };

  13.1) si queireo imprimir puedo:
    u: meal-finder\src\App.tsx
    s:
      // // const { fetch } = useFetch();

      // // useEffect(() => {
      // //   console.log('fetch');
      // //   fetch('https://www.themealdb.com/api/json/v1/1/search.php?s=Arrabiata');
      // // }, []);
14) ahora con ese custom hook lo usare
para llamar el detalle cuando de click en alguna card
  u: meal-finder\src\App.tsx
  s:
  // // const { fetch } = useFetch<Meal>();
  // //   const searchMealDetails = (meal: Meal) => {
  // //   onOpen();
  // //   const url = `${baseUrl}/lookup.php?i=${meal.idMeal}`;
  // //   fetch(url);
  // //   };
  // //   ...
  // //   ..
  // //   <MainContent
  // //     openRecipe={searchMealDetails}  //-----le paso a este componente la funcion para cundo de click pueda mandarle el id al url y asi llenar el estado de la variable "detalles"
  // //     loading={loadingMeal}
  // //     meals={dataMeal}
  // //   >
  // //   </MainContent>

   14.1) MainContent
    u: meal-finder\src\components\MainContent.tsx
    n: MainContent recibe la funcion y cuando se da click en el boton pues ahi es donde se manda el id
    s:

      // // function MainContent({ ....... openRecipe }: Props) {
      // //  .....
      // //   return (
      // //     .....
      // //       ....
      // //       <SimpleGrid columns={[1, 2, null, 3]} spacing="20px">
      // //         .......
      // //         {!loading &&
      // //           meals.map((meal) => (
      // //             //---------aqui recive el Meal
      // //             <MealCard openRecipe={() => openRecipe(meal)} key={meal.idMeal} meal={meal} />
      // //           ))}
      // //       </SimpleGrid>
      // //     </>
      // //   );
      // // }
    14.2) como el componete MeaCard tiene un boton al dar click en el boton se ejecuta la funcion 
      u:
      s:
      // // ...
      // // function MealCard({ openRecipe, meal }: Props) {
      // //   return (
      // //     .......//-------aqui al dar click va a openRecipe y como en 14.1) MainContent
      // //             //------se crea una ejecucion pasandole la meal 
      // //             //-----entonces ejecuta en el u: meal-finder\src\App.tsx la funcion 
      // //             //------searchMealDetails
      // //           <Button onClick={openRecipe} colorScheme="white" bgColor={'blue.400'}>
      // //             Ver Receta
      // //           </Button>
      

      
15) objetos dinamicos para poder hacer que si tengo muchas variables, y para no darle el nombre de todos los typos o interfaces, 
 entonces se opta por darle a cada propiedad del JSON UN DATO ESPECIFICO 
  n: por ejemplo teno algo como esto osea que tengo que definir 
    para cada variable un typo , pero somcomo se ve son de tipo "string"
    
    // // {
    // // "meals": [
    // //   {
    // //     "idMeal": "52772",
    // //     "strMeal": "Teriyaki Chicken Casserole",
    // //     "strDrinkAlternate": null,
    // //     "strCategory": "Chicken",
    // //     "strArea": "Japanese",
    // //     "strIngredient1": "soy sauce",
    // //     "strIngredient2": "water",
    // //     "strIngredient3": "brown sugar",
    // //     "strIngredient4": "ground ginger",
    // //     "strIngredient5": "minced garlic",
    // //     "strIngredient6": "cornstarch",
    // //     "strIngredient7": "chicken breasts",
    // //     "strIngredient8": "stir-fry vegetables",
    // //     "strIngredient9": "brown rice",
    // //   }
    // // ]
    // // }
  15.1) n: entonces para que yo no tenga que definir en el archivo typo:
    u: meal-finder\src\types\index.ts , 
    cada una de las variable para no dfinirlas se hace lo siguiente:

    u: meal-finder\src\types\index.ts
    s:
    // // export type MealDetails = {
    // //   //el key es el nombre del objeto y el value es el tipo de dato
    // //   //pero el tipo de dato tambien podria ser otro tipo por ejemplo number
    // //   [key: string]: string;
    // // };
  15.2) para usarlo entonces:
    u:meal-finder\src\App.tsx
    s:
        // // const { fetch } = useFetch<MealDetails>();
        // // const searchMealDetails = (meal: Meal) => {
        // //   onOpen();
        // //   const url = `${baseUrl}/lookup.php?i=${meal.idMeal}`;
        // //   fetch(url);
        // // };
        // // <GridItem p="4" bg="gray.300" area={'main'}>
        // //   <MainContent
        // //     openRecipe={searchMealDetails}
        // //     loading={loadingMeal}
        // //     meals={dataMeal}
        // //   ></MainContent>
        // // </GridItem>;

16) el skeleton de el modal 
  u: meal-finder\src\App.tsx
  s:
    // //  const { fetch, loading: loadingMealDetail, data: mealDetailData } = useFetch<MealDetails>();
    // // ...
    // //   <RecipeModal data={mealDetailData} isOpen={isOpen} onClose={onClose} loading={loadingMealDetail} />;
    // //       

|16.1) voy al componete modal y agrego el tipo 
  u:meal-finder\src\components\RecipeModal.tsx
  s:
    // // type Props = {
    // //   isOpen: boolean;
    // //   onClose: () => void;
    // //   loading: boolean;
    // //   data: MealDetails | undefined;
    // // };
    // // ...
    // // ..
          {loading ? <RecipeModalSkeleton /> : data && <RecipeModalContent data={data} />}
 16.1.2) creo el RecipeModalSkeleton
    u: meal-finder\src\components\RecipeModalSkeleton.tsx
    s:
      // // import { Container, SkeletonText } from '@chakra-ui/react';
      // // import React from 'react';
      // // type Props = {};
      // // function RecipeModalSkeleton({}: Props) {
      // //   return (
      // //     <Container>
      // //       <SkeletonText spacing="4" mt="4" mb={5} noOfLines={1} skeletonHeight={8}></SkeletonText>
      // //       <SkeletonText spacing="4" mb={5} noOfLines={1} skeletonHeight={208}></SkeletonText>
      // //       <SkeletonText spacing="4" mt="4" noOfLines={3} skeletonHeight={1}></SkeletonText>
      // //     </Container>
      // //   );
      // // }
      // // export default RecipeModalSkeleton;
  16.1.3) creo el RecipeModalContent para 16.1)
    u: meal-finder\src\components\RecipeModalContent.tsx
    s:
      // // import React from 'react';
      // // import { MealDetails } from '../types';
      // // import {
      // //   Heading,
      // //   Image,
      // //   ListItem,
      // //   ModalBody,
      // //   ModalCloseButton,
      // //   ModalHeader,
      // //   OrderedList,
      // //   Text,
      // // } from '@chakra-ui/react';

      // // type Props = {
      // //   data: MealDetails;
      // // };

      // // function RecipeModalContent({ data }: Props) {
      // //   const joinIngredients = (data: MealDetails) => {
      // //     const ingredients = [];
      // //     for (let i = 1; i <= 20; i++) {
      // //       //------> busco por el nombre de la key y si hay algo lo agrego al array
      // //       if (data[`strIngredient${i}`]) {
      // //         ingredients.push(`${data[`strIngredient${i}`]} - ${data[`strMeasure${i}`]}`);
      // //       } else {
      // //         break;
      // //       }
      // //     }
      // //     return ingredients;
      // //   };

      // //   return (
      // //     <>
      // //       <ModalHeader>{data.strMeal}</ModalHeader>
      // //       <ModalCloseButton></ModalCloseButton>
      // //       <ModalBody>
      // //         <Image width={'100%'} src={data.strMealThumb} alt={data.strMeal} />
      // //         <Heading size="md" mt="4" mb="4">
      // //           Ingredients
      // //         </Heading>
      // //         <OrderedList mb="4">
      // //           {joinIngredients(data).map((ingredient) => (
      // //             <ListItem key={ingredient}>{ingredient}</ListItem>
      // //           ))}
      // //         </OrderedList>

      // //         <Text whiteSpace="pre-line">{data.strInstructions}</Text>
      // //       </ModalBody>
      // //     </>
      // //   );
      // // }
      // // export default RecipeModalContent;

Fin del proyecto meal 






























    





      